---
title: 大数据分析与智能计算期末复习
date: 2021-12-20 16:13:09
tags: 大三自学
---


# 这里是期末对于大数据计算课程的复习嗷！！！

<!--more-->

# 大数据计算概论

- 1 EB = 103 ZB = 106 PB = 109 TB = 1012 GB
- 大数据的四V特性：
  - Volume：量大，一般PB量级
  - Variety：异构化，呈现多样性
  - Velocity：处理要求时效性
  - Value：单个数据无价值，大规模数据拥有巨大价值
- 上述多样性：
  - 种类多样性，对象多样性，来源多样性，范围多样性
- 数据定义：
  - 基本定义：数据 (data)被看作是现实世界中自然现象和人类活动所留下的轨迹
  - 计算机学科中数据的定义：所有能输入到计算机并被计算机程序处理的符号的总称，是具有一定意义的数字、字母、符号和模拟量的通称。用于计算、分析或计划某种事物的事实或信息；由计算机产生或存储的信息

- 基本属性：
  - Volume：超大规模 -> 存储架构，计算模型
  - Variety：结构，时效性，关联，数据类型，数据来源。 -> 存储，管理，查询困难。
  - Value：价值密度低 -> 整体为处理对象，处理越大，结果越优

|            | **传统数学统计学**                     | **大数据分析计算方法**                                 |
| ---------- | -------------------------------------- | ------------------------------------------------------ |
| 处理对象   | 局部数据或数据子集                     | 以数据整体或完整数据集作为处理对象                     |
| 处理方法   | 基于抽样调查的随机分析方法             | 机器学习方法  通过数据的积累来训练和改进算法和计算程序 |
| 结果正确性 | 取决于随机抽样模型产生的数据集的代表性 | 处理数据量越大，  计算结果越越优化                     |

- 大数据算法特性：

|          | **大数据计算** | **传统统计学**               | **优势**                         |
| -------- | -------------- | ---------------------------- | -------------------------------- |
| 样本空间 | 整个数据集     | 基于独立同分布原理抽取样本集 | 避免样本失真                     |
| 计算方法 | 机器学习方法   | 按照固定数学模型进行预测     | 预测结果的精度改进是一个动态过程 |

- 大数据计算系统特性：

|          | **大数据计算系统**                  | **传统数据库系统**   | **优势**                                                     |
| -------- | ----------------------------------- | -------------------- | ------------------------------------------------------------ |
| 基础模型 | 分布式文件系统  NoSQL非关系型数据库 | 关系型模型           | 支持非结构化或异构数据的存储和处理  支持分布式系统部署  支持超大规模数据集完成快速查询操作 |
| 存储格式 | 基于键值对的列存储格式              | 基于主键的行存储格式 | 更优的查询效率  更好的对计算模型的支持                       |

- 开发技术特性：

| **大数据计算系统**   | **传统数据库系统**                   | **优势**                                           |
| -------------------- | ------------------------------------ | -------------------------------------------------- |
| **多层次的分层结构** | **基于某一平台和某一标准的线性结构** | 在同一平台上尽可能多的兼容或集成不同的软件开发工具 |

- 技术标准：
  - 技术参考：
    - 技术架构参考模型
    - 计算体系主要角色
    - 标准体系框架
  - 计算模式：
    - 主要计算模式
    - 各种模式特性和优劣
    - 并行处理模式
  - 两个维度：信息链（垂直方向）和价值链（水平方向）
  - 信息链维度：数据采集，继承，分析，使用结果实现价值。
  - 价值链维度：为应用提供拥有或运行的大数据的网络，基础设施，平台等实现价值。
- 主要角色：

![image-20211220165031536](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211220165031536.png)

- 体系框架组成：

![image-20211220165101760](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211220165101760.png)

- 云计算：

  - 部署架构：

  ![image-20211220170019739](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211220170019739.png)

  - 组成：

    - 基础设施
    - 存储
    - 平台
    - 应用
    - 服务
    - 客户端

  - 优点：

    - 高可用性
    - 可拓展性
    - 按需服务
    - 经济
    - 可视化高使用性

    ![image-20211220190209520](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211220190209520.png)






# 大数据计算体系：

- 三个层次（自下往上）：
  - 存储系统
  - 处理系统
  - 应用系统
- **存储系统**：
  - 数据清洗
  - 抽取与建模（数据转化为标准存储格式）
  - 数据存储架构（集中/分布式文件系统，关系型数据库，行，列存储等）
  - 数据仓库与数据服务
  - 数据统一接口（Unified Data Access Interface）

![image-20211221111605849](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221111605849.png)

- 数据建模：
  - 概念模型：用户数据功能续需求产生，定义实体类
  - 逻辑模型：数据实体细节，约束，视图等
  - 物理模型：数据的存储实现方式，拆分，集成等
- **处理系统**：
  - 针对不同类型数据的计算模型
  - MapReduce批处理
  - 动态数据流的流计算
  - 结构话数据的大规模并发处理
  - 内存计算等
  - 分析算法
  - 运行环境的计算平台

![image-20211221112151001](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221112151001.png)

- **应用系统**：
  - 互联网，电子商务，电子政务，金融等

![image-20211221112218054](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221112218054.png)

- 存储架构：
  - 逻辑存储架构（数据库）和物理存储架构（分布式文件系统）
- 统一数据访问接口：
  - 统一数据接口用于支持分布式环境中对于跨平台异构数据库访问的数据访问层（DAL）
  - 功能：
    - 统一的数据展示，存储和管理
    - 访问接口与实现代码分离
    - 屏蔽了数据源的差异
    - 提供一个统一的访问界面和统一的查询语言

![image-20211221112610875](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221112610875.png)

- 数据处理系统：
  - 算法（回归，聚合，关联，贝叶斯）
  - 计算模型（MR，流，交互式，内存）
  - 计算平台和计算架构（Google, Hadoop , Spark）
  - 针对领域的计算引擎等

![image-20211221112739395](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221112739395.png)

- 应用系统：
  - 可视化
  - 计算模式和平台：

![image-20211221112837745](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221112837745.png)

![image-20211221113633625](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221113633625.png)

- 大数据计算架构：
  - 数据存储系统：HDFS，Hadoop , NoSQL
  - 计算处理模型：MR，TensorFlow数据流图
  - 计算关键技术：智能计算，列存储结构
  - 技术解决方案：HDFS/HBase
  - 大数据应用开发
- 计算模型与计算机构：
  - 计算模型： 抽象结构 + 计算范式 + 算法（计算模型针对领域问题提出技术解决方案的基础模型、数据结构及算法。）
  - 计算机构： 系统架构 + 软件设计 + 实现方法（计算架构提出基于上述模型、在特定计算平台上实现的技术方案框架（系统架构、软件架构与模块、数据流与数据接口、实现原理及方法等）。
- 计算模型：
  - MR
  - 图并行计算
  - 交互式处理
  - 流计算
  - 内存计算
  - 数据流图模型
- 计算架构/计算平台：
  - Hadoop / HDFS / MR
  - HAMA
  - Drill
  - Storm , Spark Stream
  - MemCloud
  - Tensorflow

# 数据采集方法：

- 系统日志数据，网络数据采集
- **系统日志数据采集：**

  - 任何程序都可以输出数据，包括OS内核，应用Server
  - Web日志包含了各种前端Web应用产生的用户访问日志，Web程序的输出日志。每条代表一次访问行为。
  - 采集目的：
    - 主要目的：日志分析。e.g. 独立IP数，关进此频次排行，点击量模型，特征分析
  - 采集工具：
    - Awstats , Webalizer，Web服务器日志统计分析。
    - 嵌入js代码统计
    - 需求变化，个性化->手动实现，绝大多数单机使用。
    - 日志主机：一个基于Unix或者Windows的服务器系统，它用来集中存储日志消息。可以集中存储来自多个数据源的日志消息，可以对系统日志信息进行备份，也可以分析日志数据。
    - 日志消息的传输：通过syslog协议实现，覆盖了几乎所有Server和Client的交互，主要采用UDP。为了提高可靠性，同样支持TCP。通过syslog协议采集日志，存储在本地磁盘上，以进行日志备份存储和分析。
- **网络数据采集：**

  - 互联网信息多，搜索引擎有局限性：
    - 通用engine包含大量无用信息
    - 网络技术发展，数据类型丰富
    - 关键字ok，语义不ok
  - 网络爬虫：
    - 既定的爬取目标，选择性抓取相关网页，面向主题的用户查询准备数据资源。
    - 技术框架：控制器（为各个线程分配工作任务）+解析器（批量下载网页并进行处理）+资源库（存储下载的网页资源，通常用大型数据库存储模型）
    - 原理：初始URL开始，算法过滤链接，保留有用的链接放入待抓取的URL队列。再根据搜索策略，选择下一个URL，重复，直到达到系统的某一停止条件。
    - 搜索策略：深度，广度，最佳优先。深度（路径），广度（主题相关性大），最佳优先（降低广度优先的算法复杂度，预测相关性并抓取，降低90%左右）
    - 网页分析算法：
      - 拓扑网页分析算法：网页链接，对于链接关系作出评价。分为：**网页粒度，网站粒度和网页块粒度**
      - 网页粒度：PageRank
      - 网站粒度：SiteRank
      - 网页块粒度：一部分指向主题相关，PageRank常常带来广告等噪声链接的干扰。
    - 框架：RBSE("spider" , "mite") , WebCrawler(广度优先解析获取URL，并排序，相似度爬行的实施爬虫)，World Wide Web Worm(Grep的UNIX命令实现，标题和URL简单索引的爬虫)，Google Crawler（全文检索和URL抽取）
- 数据采集接口：
    - 前端和后端，设备太多
    - REST API统一的API设计理论，REST从资源角度观察网络，是一种风格，而不是一个标准。对一个资源，包括获取，创建，修改和删除
  - 还有一个爬虫的小项目，感兴趣的话看看PPT嗷！






# 数据清洗与数据预处理：

- 数据可能遇到的问题：

  - 数据缺失：记录为空&属性为空
  - 数据重复：完全重复&不完全重复
  - 数据错误：异常值&不一致
  - 数据不可用：数据正确，但是不可用

- 预防脏数据出现：

  - 制定标准：
    - 统一多数据源的属性值编码
    - 属性名和属性值的含义明确
  - 优化系统设计：
    - 关键属性选项而不是手动
    - 重要属性醒目，必填
    - 异常值给出修改提示

- 处理数据缺失：

  - 缺失值的原因：
    - 设备异常
    - 输入不全
  - 缺失值处理：
    - 忽略
    - 默认值
    - 属性平均值
    - 同类样本平均值
    - 预测最可能的值

- 处理数据重复：

  - 原因：
    - 整合多个数据源的数据
    - 输入的时候重复
  - 处理：
    - 删除完全重复的记录
    - 合并不同的表加入冗余属性（例如时间戳）

- 处理数据不一致：

  - 原因：
    - 录入者录错了
    - 没有统一的标准
  - 处理：
    - 制定清洗规则表，进行匹配
    - 统计描述找到异常值

- 数据噪声：

  - 原因：

    - 记录存在偏差
    - 测量存在偏差

  - 解决：

    - 分箱算法：

      - 待处理数据放入箱子中，考察数据，采用某种方法分别对箱子中的数据进行处理。
      - 箱子：按照值划分的子区间，如果属性值位于子区间，就放入“箱子”里面。
      - 主要问题：
        - 分箱方法（如何分箱）
        - 数据平滑方法（如何对于箱子中的数据进行平滑处理）
      - 方法：
        - 等深，等宽，自定义区间
      - 例子：

      ```
      学生奖学金排序后的值（人民币元）：
      800 1000 1200 1500 1500 1800 2000 2300 2500 2800 3000 3500 4000 4500 4800 5000
      
      等深分箱法（统一权重）：按记录行数分箱，每箱具有相同的记录数，每箱记录数称为箱的权重，也称箱子的深度。
      设定权重（箱子深度）为4，上述例子分箱后的结果如下。
      箱1：800 1000 1200 1500
      箱2：1500 1800 2000 2300 
      箱3：2500 2800 3000 3500
      箱4：4000 4500 4800 5000
      
      等宽分箱法（统一区间）：在整个属性值的区间上平均分布，即每个箱的区间范围是一个常量，称为箱子宽度。
      设定区间范围（箱子宽度）为1000元人民币，分箱后:
      箱1：800 1000 1200 1500 1500 1800
      箱2：2000 2300 2500 2800 3000
      箱3：3500 4000 4500
      箱4：4800 5000 
      
      用户自定义区间：用户根据需要自定义区间
      用户自定义：如将学生奖学金划分为1000元以下、1000~2000、2000~3000、3000~4000和4000元以上几组，分箱后
      箱1：800 
      箱2：1000 1200 1500 1500 1800 2000 
      箱3：2300 2500 2800 3000  
      箱4：3500 4000 
      箱5：4500 4800 5000 
      
      ```

      - 平滑处理：
        1. 平均值平滑
        2. 边界值平滑
        3. 中值平滑

    - 回归：

      - 使用**拟合函数**对于数据进行平滑。
      - 线性回归方法：Y = aX + b，a,b为回归系数，最小二乘法可以得到a,b系数
      - 非线性回归

    - 聚类：

      - 簇：一组数据对象集合，所有对象具有 **相似性**，不同簇差距大。
      - 聚类：分组，找出并清除落在簇之外的孤立点，**孤立点即为噪声**。
      - 特点：直接形成簇并对簇进行描述，不需要任何先验知识。

- 数据集成：

  - 将多个数据源中的数据整合到一个一致的存储中
  - 模式匹配：
    - 多个数据源整合到一个一致的存储中。匹配来自不同数据源的现实世界的实体。
  - 数据冗余：
    - 同一个属性在不同的数据库中有不同的名字。
    - 一个属性可以由另外一个表导出。如：一个顾客数据表中的平均月收入属性，它可以根据月收入属性计算出来。
    - 有些冗余可以被相关分析检测到
  - 数据值冲突：
    - 来自于不同数据源的属性值或许不同。
    - 原因：表示的差距，比例尺度不同，编码差异等

- 数据变化：

  - 聚集：

    - 数据进行汇总
    - avg , count , sum , min , max

  - 数据概化：

    - 用更抽象（更高层次）的概念来取代低层次或数据层的数据对象
    - 比如：0 - 30岁 -> 年轻

  - 规范化：

    - 数据按比例缩放，使之落入一个特定区域，消除数值型属性因为大小不一而导致的结果偏差。工资收入 -> [-1.0 , 1.0]
    - 方法：
      - 最小 - 最大规范化
      - 0-均值规范化（z-score规范化）
      - 小数定标规范化
    - 最小 - 最大规范化：

    ![image-20211221205934241](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221205934241.png)

    如果取值超过[old_min,old_max]就会出错

    ![image-20211221210032234](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210032234.png)

  - 属性构造：

    - 利用已有属性构造出新属性，并加入到集合中挖掘更深层次的模式知识，提高结果准星
    - 长，宽属性 -> 面积

- 数据规约（数据消减）：

  - 大规模数据时间过大

  - 数据规约（消减）用于从庞大数据集中获得一个觐见的数据集合。提高完整性，挖掘效率高，结果基本相同。

  - 标准：

    - 规约的时间不应该超过或“抵消”在规约后的数据上挖掘节省的时间。
    - 数据小得多，分析结果相同。

  - 数据立方体聚集：

    - 数据立方体是数据的多维建模和表示，由维和事实组成。
    - 数据立方体聚集定义——将n维数据立方体聚集为n-1维的数据立方体。

    例子一：

    ![image-20211221210548883](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210548883.png)

    ![image-20211221210557799](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210557799.png)

    例子二：

    ![image-20211221210644122](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210644122.png)

    上面两个例子 -> 数据量明显减少，但是分析任务所需的信息没有丢失。

    例子三：

    ![image-20211221210800154](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210800154.png)

    ![image-20211221210805175](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221210805175.png)

    每个单元存放一个聚集值，对应于多维空间的一个数据点。每个属性可能存在概念分层，允许在多个抽象层进行数据分析。

  - 维规约：

    - 去掉无关属性，目标：寻找出最小的属性子集并确保新数据子集的概率分布尽可能接近原来数据集的概率分布。
    - 选择相关属性自己：
      - 逐步向前，选择最优属性直到选不出或阈值
      - 逐步向后，删除最差属性直到选不出或与之
      - 向前和向后结合
      - 判定树（决策树）归纳：决策树归纳学习，没有出现的均认为无关，删除。
      - 基于统计分析的规约

  - 数据压缩：

    - 用数据编码或者变换，得到原始数据的压缩表示。
    - 在数据挖掘领域通常使用的两种数据压缩方法均是有损的：
      - 主成分分析法（PCA），把原数据投影到一个较小的空间，实现数据压缩。
      - 小波转换
    - 压缩算法分类：
      - 无损压缩：不丢失任何信息还原压缩数据
        - 字符串压缩
        - 部分算法
      - 有损压缩：重新构造原数据近似表示
        - 音频/视频压缩
        - 有时可以在不解压整体数据的情况下，重构某个片断

  - 离散化与概念分层生成：

    - 三种类型的属性值：

      - 名称型 - 无需集合中的值
      - 序数 - 有序结合中的值
      - 连续值 - 实数

    - 离散化技术：

      - 通过将属性域值范围划分为若干区间，帮助消减一个连续（取值）属性的取值个数。

    - 概念分层：

      - 一组由底层概念集成到高层概念集的映射，允许在各种抽象级别上处理数据。
      - 可以用树来表示，一个节点代表一个概念。

      ![image-20211221212546743](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221212546743.png)



# 数据分析算法I（数据关系）：

- **数据分析**是从海量数据中提取信息的过程，以机器学习算法为基础。模拟学习，**获取新的知识和技能**，不断改善分析过程。
- 整体框架图：

![image-20211221212752266](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211221212752266.png)

## TF-IDF:

- **在一堆文档中选择属于每个文本最具有代表性的词汇**，它是一种常用于检索系统的加权技术。
- Term Frequency-Inverse Document Frequency
- 关键词定义：
  - 文档的高度 **概括**
  - **区分** 不同的文档
- 词袋模型：
  - **第一步：文本转换到数量空间**。
  - 文本映射到向量表示的空间中，称为 **向量空间模型**：
    - 词袋模型广泛用于NLP和信息检索的词语模型。
    - 若干词语直接放入一个 **袋子**，**不考虑词语间的语法和相互顺序**。

一个例子：

| **文本** | **语句**                               |
| -------- | -------------------------------------- |
| **A**    | 小张 喜欢   打 篮球 和   打 羽毛球     |
| **B**    | 小李 喜欢   打 羽毛球                  |
| **词袋** | 小张、喜欢、打、篮球、和、羽毛球、小李 |

| **文本**  | **语句**                                                    |
| --------- | ----------------------------------------------------------- |
| **A**     | 小张(1)、喜欢(1)、打(2)、篮球(1)、和(1)、羽毛球(1)、小李(0) |
| **A向量** | 1 1 2 1 1 1 0                                               |
| **B**     | 小张(1)、喜欢(1)、打(1)、篮球(0)、和(0)、羽毛球(1)、小李(1) |
| **B向量** | 1 1 1 0 0 1 1                                               |

- 易于理解，但**不能进行更深层次的语义处理**，**擅长的是与词频相关、忽略词序和语法的文本的文本信息处理。**
- TF-IDF算法：
  - 基本思想：文档中每个词的重要性与它在当前文档中出现的次数成正比，但是与它在其他文件中出现的次数成反比。
  - 推论：倘若一个词语在某一文档中出现的频率很高，并且在其他文档集合中出现的频率很低，那么则认为该词语对文件A有一定的代表性，能够通过该词与其他文档形成较好的内容区分能力。
- 算法具体例子：

| **文档** | **文档中对应词语集合**               |
| -------- | ------------------------------------ |
| **A**    | 努力 向前 奋斗 奋斗 使得 未来   更好 |
| **B**    | 创新 创新 万众 智慧                  |
| **C**    | 奋斗 是 人生 的 一部分               |

![image-20211222111908317](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222111908317.png)

- 网上的一个例子：

有很多不同的数学公式可以用来计算TF-IDF。这边的例子以上述的[数学公式](https://baike.baidu.com/item/数学公式)来计算。词频 (TF) 是一词语出现的次数除以该文件的总词语数。假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3/100=0.03。一个计算文件频率 (IDF) 的方法是文件集里包含的文件总数除以测定有多少份文件出现过“母牛”一词。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 lg(10,000,000 / 1,000)=4。最后的TF-IDF的分数为0.03 * 4=0.12。

- 缺点：
  - 对于 **短文本** 和 **过长文本** 的处理不是很好。
  - 忽视了文档中 **语义和语法** 的表达
  - 词语之间必须 **完全匹配**，相似词语无法处理或无法有效匹配



## 余弦相似性：

- 一个简单的指标是Jaccard系数，用于个体的特征属性通过符号度量或者布尔值标识，适合集合的计算。
- 对于文本，直观的想法是：两篇文章越相似，则它们词语的交集越多。

![image-20211222112754875](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222112754875.png)

- Jaccard的理论基础支持不够，因为仅依靠是否出现去判定两者的相似度不够精准。
- 引入余弦相似性，通过余弦的方式计算相似度，将词语是否出现变更为词语在文本中的权重。

![image-20211222113203970](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222113203970.png)

- 一个例子：

| **文本**          | **A**                                                        | **B**                                    |
| ----------------- | ------------------------------------------------------------ | ---------------------------------------- |
| **内容**          | 数据价值是一种数据艺术                                       | 算法价值是一种算法艺术                   |
| **分词结果**      | 数据 价值   是 一种 数据   艺术                              | 算法 价值   是 一种 算法   艺术          |
| **向量集**        | 数据 算法 价值   是 一种 艺术                                |                                          |
| **词频计算**      | 数据(2)算法(0)价值(1)是(1)一种(1)艺术(1)                     | 数据(0)算法(2)价值(1)是(1)一种(1)艺术(1) |
| **特征向量**      | 2 0   1 1 1 1                                                | 0 2   1 1 1 1                            |
| **Jaccard**相似度 | ![image-20211222113448293](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222113448293.png) |                                          |
| **余弦相似度**    | ![image-20211222113511285](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222113511285.png) |                                          |

Jaccard相似度中：A交B的模是A和B相交向量中不为0的个数（向量的模的定义），推断一下就有结果了嗷！！！

余弦相似度更加暴力一些：按照上面的公式直接代入即可。

- 优缺点：
  - Jaccard相似性只关心个体间特征属性是否相同，反映了样本交集与并集（总集）的差异
  - A和B文本，相同词语较多，但两句的意思迥异，余弦相似度更符合实际情况。
  - 优点：简单而有效。
  - 缺点：数据维数高，计算复杂度也越高，不适应当前的（数亿级别）大数据。



## Apriori：

- **关联规则**用于挖掘出可能具有的价值信息。数据间的关系有商业价值。 -> 啤酒与尿布。
- 反映了多个事务之间的 **依存性和关联性**。
- 频繁项集算法 -> 超时商品分析管理，消费习惯分析。利用频繁项集的先验知识，不断地按照层次进行迭代，计算数据集中的所有可能的频繁项集
- 概念：
  - 项集：项的集合
  - 关联规则：X -> Y的蕴含表达式
  - 支持度：X , Y同时发生的概率
  - 置信度：项集X发生的情况下，项集Y发生的概率
  - 最小支持度：人为按照实际意义规定的阈值，表示项集在统计意义上的最低重要性。
  - 最小置信度：人为按照实际意义规定的阈值，表示关联规则最低可靠性。
    - 如果关联规则的最小支持和最小置信同时达到，则称关联规则为 **强规则**
  - 频繁项集：满足最小支持度的所有项集，称为频繁项集
- Apriori两大定理：
  - 如果一个集合是频繁项集，那么它的所有**子集**都是频繁项集合。集合{苹果、梨子}是频繁项集，则子集{苹果}、{梨子}均属于频繁项集。
  - 如果一个集合它不是频繁项集合，那么它的所有超集都不是频繁项集。例如，集合{苹果}不属于频繁项集，那么它的超集{苹果、梨子}也不属于频繁项集。

![image-20211222115703441](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222115703441.png)

- 算法流程：
  - 扫描历史数据，并对每项数据进行**频率次数统计**
  - 构建候选项集$C_1$，并计算其支持度。
  - 对候选项集的支持度进行筛选，从而形成频繁项集$L_1$。
  - 对频繁项集$L_1$进行连接生成候选项集$C_2$。
  - 重复上述步骤，最终形成频繁*K*项集或者最大频繁项集。

例子：

| **序号** | **购买商品列表**         |
| -------- | ------------------------ |
| **1**    | 牛奶、纸巾、矿泉水       |
| **2**    | 饼干、纸巾、口香糖       |
| **3**    | 牛奶、饼干、纸巾、口香糖 |
| **4**    | 饼干、口香糖             |

扫描事务集，并且统计每个候选项的支持度：

| **候选项集** | **支持度** |
| ------------ | ---------- |
| **牛奶**     | 0.5        |
| **饼干**     | 0.75       |
| **纸巾**     | 0.75       |
| **矿泉水**   | 0.25       |
| **口香糖**   | 0.75       |

消除低于最小支持度的候选项，生成频繁1项集：

| **频繁项集** | **支持度** |
| ------------ | ---------- |
| **牛奶**     | 0.5        |
| **饼干**     | 0.75       |
| **纸巾**     | 0.75       |
| **口香糖**   | 0.75       |

根据频繁1项集，生成候选2项集，扫描事务集，统计候选2项集的支持度：

| **候选项集**     | **支持度** |
| ---------------- | ---------- |
| **牛奶、饼干**   | 0.25       |
| **牛奶、纸巾**   | 0.50       |
| **牛奶、口香糖** | 0.25       |
| **饼干、纸巾**   | 0.50       |
| **饼干、口香糖** | 0.75       |
| **纸巾、口香糖** | 0.50       |

生成频繁2项集：

| **频繁项集**     | **支持度** |
| ---------------- | ---------- |
| **牛奶、纸巾**   | 0.50       |
| **饼干、纸巾**   | 0.50       |
| **饼干、口香糖** | 0.75       |
| **纸巾、口香糖** | 0.50       |

根据频繁2项集，生成候选3项集，扫描事务集，统计候选3项集的支持度：

| **候选项集**           | **支持度** |
| ---------------------- | ---------- |
| **饼干、纸巾、口香糖** | 0.50       |

{牛奶, 纸巾, 饼干}，它的子集不属于频繁项集，因此超级也不属于频繁项集

生成频繁3项集：

| **频繁项集**           | **支持度** |
| ---------------------- | ---------- |
| **饼干、纸巾、口香糖** | 0.50       |

- 当得到了频繁项集$L_3$、$L_2$后，超市可以优先根据$L_3$，将“饼干、纸巾、口香糖”放在同一货架或者连续货架中，然后再考虑根据$L_2$放置货架商品。
- 算法缺点：
  - 产生候选项集时产生较多的组合，没有考虑将一些无关的元素排除后再进行组合。
  - 每次计算项集的过程都会扫描原始的数据表，对于数据量较大的系统而言，重复扫描开销大。
- 解决途径：
  - 压缩数据表
  - 哈希表快速查找来进行计数统计
  - 合理选样
  - FP-Growth算法



## PageRank：

- 数据关系还可以应用到**搜索引擎**和**推荐系统**
- 思想：看一个人怎样，看他有什么朋友就知道了。–被越多优质的网页所指的网页，它是优质的网页的概率就越大。
- 数量假设：入链越多，越重要。质量假设：质量越高的页面指向它，页面越重要。
- 算法步骤：
  - 给每个网页初始化PR值为1/N，其中*N* 为网页总数
  - 根据投票算法不断迭代，直到分布平稳为止。

![image-20211222132511018](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222132511018.png)

![image-20211222132434626](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222132434626.png)

- 一个例子：

![image-20211222132559260](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222132559260.png)

|            | PR(A)  | PR(B)  | PR(C)  | PR(D)  |
| ---------- | ------ | ------ | ------ | ------ |
| **初始值** | 0.25   | 0.25   | 0.25   | 0.25   |
| 第1次迭代  | 0.125  | 0.333  | 0.083  | 0.458  |
| 第2次迭代  | 0.1665 | 0.4997 | 0.0417 | 0.2912 |
| **……**     | ……     | ……     | ……     | ……     |
| 第n次迭代  | 0.1999 | 0.3999 | 0.0666 | 0.3333 |

- 网页没有出度—>排名泄露，所有网页的PR值都趋向于0。解决方法：强制A对所有的网页包括自己都有出链，PR(B)=P(A)/4+PR(D)/2

- 一些规律：

  - 网页没有入度—>排名下沉，该网页PR值趋于0

  ![image-20211222133249535](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222133249535.png)

  - 网页只有对自己有出链，或者几个网页的出链形成封闭—>排名上升，这些网页的PR值只增不减

  ![image-20211222133255160](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222133255160.png)

- 改进版算法：

![image-20211222133459607](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222133459607.png)

![image-20211222133540244](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222133540244.png)

- 优点：
  - 与查询无关的静态算法，所有网页的PageRank值通过**离线计算**获得。有效减少在线查询时的计算量，极大降低了查询响应时间。（只和网络关系有关，和查询无关）。
- 缺点：
  - **过分相信链接关系**，而一些权威网页往往是相互不链接的；忽视了**主题相关性**；旧的页面等级会比新页面高。





# 数据分析算法II（分类与聚类）：

- 模式分类问题在大数据分析中得到广泛的应用——它是数据的最基本处理方式之一。
- 定义：
  - 监督学习：分类
  - 非监督学习：聚类



## 朴素贝叶斯分类器

- 分类过程：
  - 训练
  - 识别
- 朴素贝叶斯分类器是一种非常传统的分类方法：
  - 具有深刻的统计数学基础。
  - **Naive**，假设样本的特征之间是彼此 **独立** 的。
- 贝叶斯定理：
  - ![image-20211222160112951](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222160112951.png)
  - ![image-20211222160129273](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222160129273.png)
  - P(C)表示选取某个类别的概率密度，分布未知时，假设P(C)服从一个分布，例如贝努利模型P(c)=(|$D_c$ |)/|D|  ，|D|表示样本总数，$D_c$表示属于*c* 类的样本数
- 分类问题例子：

| **类别**   | **鲜红值** | **鲜红值** | **直径** | **直径** | **质量** | **质量** |
| ---------- | ---------- | ---------- | -------- | -------- | -------- | -------- |
|            | 标准差     | 均值       | 标准差   | 均值     | 标准差   |          |
| **车厘子** | 0.8        | 0.018      | 1        | 0.0183   | 8.7675   | 0.077    |
| **樱桃**   | 0.575      | 0.013      | 0.845    | 0.0129   | 7.3125   | 0.017    |

- 贝叶斯补充：

先验概率：是指根据以往经验和分析得到的概率。

举个例子：如果我们对西瓜的色泽、根蒂和纹理等特征一无所知，按照常理来说，西瓜是好瓜的概率是60%。那么这个概率P（好瓜）就被称为先验概率。

后验概率：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。

![image-20211222204637499](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222204637499.png)

题目一个：

| **类别**   | **鲜红值** | **直径** | **质量** |        |        |       |
| ---------- | ---------- | -------- | -------- | ------ | ------ | ----- |
| 均值       | 标准差     | 均值     | 标准差   | 均值   | 标准差 |       |
| **车厘子** | 0.8        | 0.018    | 1        | 0.0183 | 8.7675 | 0.077 |
| **樱桃**   | 0.575      | 0.013    | 0.845    | 0.0129 | 7.3125 | 0.017 |



| **水果类型** | **鲜红值（色度比）** | **直径（****cm****）** | **质量（****g****）** |
| ------------ | -------------------- | ---------------------- | --------------------- |
| **车厘子**   | 0.81                 | 1.02                   | 8.85                  |
| **车厘子**   | 0.82                 | 0.98                   | 8.67                  |
| **车厘子**   | 0.78                 | 0.99                   | 8.75                  |
| **车厘子**   | 0.79                 | 1.01                   | 8.80                  |
| **樱桃**     | 0.56                 | 0.85                   | 7.32                  |
| **樱桃**     | 0.58                 | 0.86                   | 7.33                  |
| **樱桃**     | 0.59                 | 0.83                   | 7.29                  |
| **樱桃**     | 0.57                 | 0.84                   | 7.31                  |
|              |                      |                        |                       |
| **？？？**   | 0.8                  | 0.86                   | 8                     |

![image-20211223100943028](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223100943028.png)

- 轩哥补充：

![image-20211223101212945](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223101212945.png)

![image-20211223101143514](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223101143514.png)





## AdaBoost分类器

- AdaBoost算法的思想是从这些训练数据中学习一系列弱分类器，然后将这些弱分类器组合成强分类器。
- 基于测试过程中的错误反馈调节分类器的分类效果
- 例子：

| **序号** | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** | **10** |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ |
| **X**    | 0     | 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8     | 9      |
| **Y**    | 1     | 1     | 1     | -1    | -1    | -1    | 1     | 1     | 1     | -1     |

1. 初始化样本权重 : $D_1$={0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1}
2. **设定阈值: 2.5，设计弱分类器 $G_m$ (x):x→{-1,1}**，![image-20211222205605606](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222205605606.png)
3. 计算误差率：ϵ=0.3

![image-20211222205643057](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222205643057.png)

4. 计算弱分类器G_m (x)的权重 ， ![image-20211222205706505](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222205706505.png)

![image-20211222205718485](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222205718485.png)

- 不断迭代：



![image-20211222210033464](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222210033464.png)

- 从上述三轮迭代可以看出，如果某个样本被分错，那么它们在下一轮迭代中的权值将被增大，从而被凸显出来；同时，分类正确的样本的权值在下一轮将被降低。错分样本权值增大，正确样本权值减小，而在下一轮迭代中，选择误差率最低的阈值来设计该轮的弱分类器。通过这样的方式，误差率ϵ不断降低。



- 轩哥补充：

![image-20211223102056027](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102056027.png)

![image-20211223102113304](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102113304.png)

![image-20211223102146685](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102146685.png)

![image-20211223102214064](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102214064.png)

![image-20211223102226768](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102226768.png)

![image-20211223102238534](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102238534.png)

![image-20211223102258121](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102258121.png)

![image-20211223102309427](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223102309427.png)











## 支持向量机（SVM）

- 适用于**小样本**、高维模式的识别
- 基于**结构风险最小化**：经验风险和置信区间的折衷

线性SVM：

![image-20211222212138093](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212138093.png)

非线性SVM：

![image-20211222212226899](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212226899.png)

逻辑回归：

![image-20211222212341773](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212341773.png)

感知机：

![image-20211222212412670](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212412670.png)

深度学习：

![image-20211222212511279](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212511279.png)

- 空间的转换：

![image-20211222212537141](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222212537141.png)

























## K临近算法

- K邻近算法查找的是最邻近的K个样本点，是一种用于分类和回归的统计方法
- 算法流程：
  - 计算待测样本与每个训练样本的距离。
  - 计算并获得待测样本附近的K个样本。
  - 根据分类决策规则（如多数表决）决定待测样本的类别。

- 例子：

| **电影名称**             | **电影类型** | **观众** |
| ------------------------ | ------------ | -------- |
| **《寒战2》**            | 动作         | A、C、D  |
| **《变形金刚**3》        | 科幻         | A、B、C  |
| **《大鱼海棠》**         | 动画         | E、F     |
| **《独立日：卷土重来》** | 科幻         | A、C、E  |
| **《惊天魔盗团**2》      | 动作         | B、D、F  |
| **《海底总动员**2》      | 动画         | D、E、B  |

电影院新上映《星球大战：第八部》，现在观众B、D、E已经表现出浓厚的兴趣购票观看，但是缺乏其他观众的观影兴趣，因此电影院试图通过历史数据了解其他用户，以便安排播放档期。

- 计算观众的余弦相似度：例如A和B，并集{寒战2、变形金刚3、独立日：卷土重来、惊天魔盗团2、海底总动员2}，那么A=(1,1,1,0,0)，B=(0,1,0,1,1)，A、B的余弦相似度为0.33
  约定两者的相似度不小于0.33时，视为相关用户

| **观众**  | **相似观众**                                                 |
| --------- | ------------------------------------------------------------ |
| **观众**A | 观众B（0.33）、观众D（0.33）、观众E（0.33）                  |
| **观众**B | 观众A（0.33）、观众C（0.33）、观众D（0.66）、观众E（0.33）、观众F（0.41） |
| **观众**C | 观众B（0.33）、观众D（0.33）、观众E（0.33）                  |
| **观众**D | 观众A（0.33）、观众B（0.66）、观众C（0.33）、观众E（0.33）、观众F（0.41） |
| **观众**E | 观众A（0.33）、观众B（0.33）、观众C（0.33）、观众D（0.33）、观众F（0.41） |
| **观众**F | 观众B（0.41）、观众D（0.41）、观众E（0.41）                  |

B、D、E对《星球大战》是感兴趣的，只考察A、C、F

| **观众** | **K=3**邻居                                 | **兴趣值**              |
| -------- | ------------------------------------------- | ----------------------- |
| **A**    | 观众B（0.33）、观众D（0.33）、观众E（0.33） | (0.33+0.33+0.33)÷3=0.33 |
| **C**    | 观众B（0.33）、观众D（0.33）、观众E（0.33） | (0.33+0.33+0.33)÷3=0.33 |
| **F**    | 观众B（0.41）、观众D（0.41）、观众E（0.41） | (0.41+0.41+0.41)÷3=0.41 |

- **KNN**的缺点：
  - 不平衡样本
  - 计算量相对较大
  - *K* 值的设定对算法的结果有较大的影响
- 解决途径：在实际应用过程中将类别典型的样本纳入样本库中



## K-Means聚类

- 聚类方式：
  - 自上而下
  - 自下而上
- 核心思想：人以类聚，物以群分
- 流程：
  1. 随机选择K个点作为种子中心点。
  2. •其余的数据点，依次判断它与K个中心点的距离，距离最近的表明它属于这个聚类。
  3. 重新计算，以新的类集合的平均值作为类别中心点。整个过程不断迭代计算，直到达到预先设定的迭代次数或中心点不再频繁波动。
- 例子：

```
“中国  女足  绝对  主力  伤别  奥运  18+4  名单  做  调整”
“雷军  否认  小米  手机  耍猴  搞  饥饿  营销  绝对  误解”
“中国  两名  南苏丹  维和  牺牲  战士  灵柩  运抵  乌干达”
“惧怕  寨卡  温网  亚军  拉奥尼奥  宣布  退出  里约  奥运”
“手机  市场  陷入  滞胀  部分  中小品牌  死  上半年”
“抗洪  战士  刘景泰  失联  7天  其母  战士们  辛苦  别  搜”
“阿根廷  男足  奥运  名单  马竞  主帅  之  子  多名  大将  缺阵”
“网购  手机  中  现  陌生人  照片  疑为  翻新机  商家  进货  渠道  正规”
“中国  赴  南苏丹  维和  步兵营  为  牺牲  战士  举行  告别  仪式”
```

1. 设定*K*=3，即确定聚类个数

- 距离计算可以使用欧氏距离，但是对于新闻标题的距离，实质是句子的相似度，句子之间的相似度越高，则距离越小，因此句子的相似可使用余弦相似性进行计算。

2. 对中心点进行调整，并不断迭代计算

- 在迭代计算之前，需要假定初始状态下三个聚类的中心点位置，通常是随机句子中的三句，分别为聚类K_1,K_2, K_3的中心。
- 将其他句子分别与三个初始类簇中心点计算相似度，例如，第*m* 个句子S_m，分别计算其与K_1,K_2, K_3的中心句子相似度d_m1,d_m2, d_m3，若值d_m1最小，则说明在本次迭代中S_m属于聚类K_1。
- 完成一次迭代之后，需要重新确定聚类K_1,K_2, K_3的中心句子。
- 确定一个聚类的中心句子的方式，是根据类中句子之间的相似度，设![image-20211222211328099](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222211328099.png)表示第K个类簇中所有句子与类簇的第i个句子的平均相似度，n表示当前迭代过程中第K个类簇的句子数，取最小平均相似度的句子作为新的类簇中心句。
3. 迭代，直至收敛。

聚类结果：

| **聚   类**    | **新闻标题**                                                 |
| -------------- | ------------------------------------------------------------ |
| **第一聚类簇** | 中国女足绝对主力伤别奥运 18+4名单将做调整  惧怕寨卡！温网亚军拉奥尼奥宣布退出里约奥运  阿根廷男足奥运名单：马竞主帅之子 多名大将缺阵 |
| **第二聚类簇** | 雷军否认小米手机耍猴搞饥饿营销：绝对是误解  手机市场陷入滞胀 部分中小品牌‘死’在上半年  网购手机中现陌生人照片疑为翻新机 商家：进货渠道正规 |
| **第三聚类簇** | 中国两名南苏丹维和牺牲战士灵柩运抵乌干达  抗洪战士刘景泰失联7天 其母：战士们辛苦别搜了  中国赴南苏丹维和步兵营为牺牲战士举行告别仪式 |















# 数据分析算法III（数据决策）

- 决策树是一个预测模型，代表**对象属性与对象值之间的一种映射关系**。
- 决策树经常用于数据挖掘中的**数据分析和预测**。
- 决策树是一种特殊的树结构，由决策图和可能的结果组成，用来**创建到达目标的规划。**

- 例子：

| **天气** | **温度** | **湿度** | **刮风** | **是否打篮球** |
| -------- | -------- | -------- | -------- | -------------- |
| **晴天** | 高       | 低       | 否       | 打篮球         |
| **晴天** | 高       | 低       | 是       | 打篮球         |
| **晴天** | 中       | 低       | 否       | 打篮球         |
| **晴天** | 中       | 中       | 否       | 打篮球         |
| **晴天** | 中       | 低       | 是       | 打篮球         |
| **小雨** | 低       | 高       | 否       | 不打篮球       |
| **小雨** | 低       | 高       | 是       | 不打篮球       |
| **小雨** | 中       | 高       | 否       | 不打篮球       |
| **阴天** | 低       | 高       | 否       | 不打篮球       |
| **阴天** | 中       | 高       | 否       | 打篮球         |
| **阴天** | 中       | 中       | 是       | 打篮球         |

- 决策树的构成：
  - 一棵决策树通常由结点和有向边组成，结点包括**根结点、内部结点和叶节点**
  - 根结点和内部节点表示一个特征或者属性，叶节点表示一个具体分类。

![image-20211222215704715](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222215704715.png)



## ID3算法：

- ID3算法是以信息论为基础，以**信息熵和信息增益**为衡量标准，从而实现对数据的归纳分类。（根据信息增益运用自顶向下的贪心策略是ID3建立决策树的主要方法）

- 决策树关键问题：树分支的**裂变**依据，**属性选择**。

- 信息熵：

  - **信息熵**是接收信息量的平均值，用于**度量信息的不确定程度**，是随机变量的均值。
  - 信息熵的处理信息是一个让信息的熵减少的过程。
  - 假设X是一个离散的随机变量，且它的取值有限范围R={$x_1$,$x_2$,⋯,$x_n$}，设$p_i$=P{X=$x_i$}，则X的熵：

  ![image-20211222220034994](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222220034994.png)

  - 信息增益用于度量属性A对降低样本集合X的熵的贡献大小，也就是度量A对使信息有序的贡献：

  ![image-20211222220130165](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222220130165.png)

- 算法流程：

  1. **计算所有属性**的信息增益
  2. 选择 **信息增益最大** 的属性裂变
  3. 如果样本集的类别属性只含有单个属性，则分支为叶子节点。判断属性值并标上相应的符号，然后返回调用处。子样本集递归调用此算法。

- 例子：

| **考试成绩** | **作业完成情况** | **出勤率** | 是否能够通过总评 |
| ------------ | ---------------- | ---------- | ---------------- |
| **优**       | 优               | 高         | 是               |
| **优**       | 良               | 高         | 是               |
| **良**       | 优               | 高         | 是               |
| **良**       | 良               | 高         | 是               |
| **及格**     | 良               | 高         | 是               |
| **及格**     | 及格             | 高         | 是               |
| **及格**     | 不及格           | 低         | 否               |
| **及格**     | 不及格           | 高         | 是               |
| **不及格**   | 及格             | 低         | 否               |
| **不及格**   | 不及格           | 低         | 否               |

![image-20211222221026766](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222221026766.png)

上面的信息熵是针对考试成绩是否及格和是否能够通过总评来计算的嗷！！！

算出每一个的信息增益嗷！！！

![image-20211222221053484](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222221053484.png)

出勤率=高子集：

| **考试成绩** | **作业完成情况** | 是否能够通过总评 |
| ------------ | ---------------- | ---------------- |
| **优**       | 优               | 是               |
| **优**       | 良               | 是               |
| **良**       | 优               | 是               |
| **良**       | 良               | 是               |
| **及格**     | 良               | 是               |
| **及格**     | 及格             | 是               |
| **及格**     | 不及格           | 是               |

出勤率=低子集：

| **考试成绩** | **作业完成情况** | 是否能够通过总评 |
| ------------ | ---------------- | ---------------- |
| **及格**     | 不及格           | 否               |
| **不及格**   | 及格             | 否               |
| **不及格**   | 不及格           | 否               |

注：这里不需要再递归，因为出勤率已经可以确定总评通过与否，满足迭代停止条件。



## C4.5算法：

- C4.5是J. Ross Quinlan基于ID3算法改进。
  - 用信息增益率来选择属性，克服了ID3算法选择属性时偏向选择取值多的属性的不足。
  - 在决策树构造过程中支持剪枝。
  - 能够完成对连续属性的离散化处理。
  - 能够对缺失值数据进行处理。
    - 丢弃、赋予常见值
    - 概率分配：不缺失的部分中为1占60%，为0占40%；则在此属性裂变时，把缺失部分的60%分配给属性为1的分支，40%分配给属性为0的分支
- 算法流程：
  - 计算出样本集合X的信息熵。
  - 计算每个属性的信息增益值Gain(V)。
  - 计算分裂信息度量（见下）
  - 利用公式IGR(V)=Gain(V)/H(V) 计算信息增益率。
  - 选择信息增益率最高的属性作为决策树结点进行分裂。
  - 在各个结点的子集上通过步骤2-6递归，直至满足停止条件。

![image-20211222221729459](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211222221729459.png)

- 例子：

| **考试成绩** | **作业完成情况** | **出勤率** | 是否能够通过总评 |
| ------------ | ---------------- | ---------- | ---------------- |
| **优**       | 优               | 高         | 是               |
| **优**       | 良               | 高         | 是               |
| **良**       | 优               | 高         | 是               |
| **良**       | 良               | 高         | 是               |
| **及格**     | 良               | 高         | 是               |
| **及格**     | 及格             | 高         | 是               |
| **及格**     | 不及格           | 低         | 否               |
| **及格**     | 不及格           | 高         | 是               |
| **不及格**   | 及格             | 低         | 否               |
| **不及格**   | 不及格           | 低         | 否               |

![image-20211223115546908](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223115546908.png)

![image-20211223115607365](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223115607365.png)

![image-20211223144421692](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223144421692.png)





## Cart算法：

- 决策树主要有两种类型：**分类树和回归树**。
- 分类和回归树，即**CART**（classification and regression tree），最先由Breiman等提出：
  - 决策树生成：基于训练数据集生成决策树，生成的决策树尽量大
  - 决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。
- 本节只关注分类树。
- 与ID3的不同，用于选择变量的度量不同。ID3使用的度量是信息增益，CART使用的不纯度量是**GINI指数**。
- 对于连续的目标变量，在CART算法中，预测目标变量的方法是**找出一组基于树的回归方程**。
- 对于具有两个以上类别的多类问题，CART算法可能考虑将目标类别合并成两个超类别（双化）。
- GINI指数：
  - ![image-20211223145109325](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223145109325.png)
  - •基尼指数GINI(D)表示集合D的不确定性，基尼指数GINI(D, A)表示经A=α分割后集合D的不确定性 -> 基尼指数值越大，样本集合的不确定性（不纯度）也越大
- 一个例子：

| **ID** | $A_1$**年龄** | $A_2$有工作 | $A_3$有自己的房子 | $A_4$信贷情况 | **类别** |
| ------ | ------------- | ----------- | ----------------- | ------------- | -------- |
| **1**  | 青年          | 否          | 否                | 一般          | 否       |
| **2**  | 青年          | 否          | 否                | 好            | 否       |
| **3**  | 青年          | 是          | 否                | 好            | 是       |
| **4**  | 青年          | 是          | 是                | 一般          | 是       |
| **5**  | 青年          | 否          | 否                | 一般          | 否       |
| **6**  | 中年          | 否          | 否                | 一般          | 否       |
| **7**  | 中年          | 否          | 否                | 好            | 否       |
| **8**  | 中年          | 是          | 是                | 好            | 是       |
| **9**  | 中年          | 否          | 是                | 非常好        | 是       |
| **10** | 中年          | 否          | 是                | 非常好        | 是       |
| **11** | 老年          | 否          | 是                | 非常好        | 是       |
| **12** | 老年          | 否          | 是                | 好            | 是       |
| **13** | 老年          | 是          | 否                | 好            | 是       |
| **14** | 老年          | 是          | 否                | 非常好        | 是       |
| **15** | 老年          | 否          | 否                | 一般          | 否       |

计算各特征的基尼指数，选择最优特征以及其最优切分点

以计算GINI(D,A_1=青年)为例：

​	$A_1$=青年，$D_1$={青年}，$D_2$={中年,老年}

​	|$D_1$|=5,|$D_2$|=10,|$D$|=15。

​	![image-20211223145522691](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223145522691.png)

![image-20211223145618128](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223145618128.png)

根据A3 = 是来分割（思考：如果一项只能取到两个值的话，这个时候就只用算一个嗷，因为两个的结果是一样的嗷！！！）

裂变之后，表格变为：

| **划分** | **ID** | $A_1$**年龄** | $A_2$**有工作** | $A_3$**有自己的房子** | $A_4$**信贷情况** | **类别** |
| -------- | ------ | ------------- | --------------- | --------------------- | ----------------- | -------- |
| $D_1$    | 4      | 青年          | 是              | 是                    | 一般              | 是       |
|          | 8      | 中年          | 是              | 是                    | 好                | 是       |
|          | 9      | 中年          | 否              | 是                    | 非常好            | 是       |
|          | 10     | 中年          | 否              | 是                    | 非常好            | 是       |
|          | 11     | 老年          | 否              | 是                    | 非常好            | 是       |
|          | 12     | 老年          | 否              | 是                    | 好                | 是       |
| $D_2$    | 1      | 青年          | 否              | 否                    | 一般              | 否       |
|          | 2      | 青年          | 否              | 否                    | 好                | 否       |
|          | 3      | 青年          | 是              | 否                    | 好                | 是       |
|          | 5      | 青年          | 否              | 否                    | 一般              | 否       |
|          | 6      | 中年          | 否              | 否                    | 一般              | 否       |
|          | 7      | 中年          | 否              | 否                    | 好                | 否       |
|          | 13     | 老年          | 是              | 否                    | 好                | 是       |
|          | 14     | 老年          | 是              | 否                    | 非常好            | 是       |
|          | 15     | 老年          | 否              | 否                    | 一般              | 否       |

![image-20211223151500208](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223151500208.png)

- CART连续属性处理：

![image-20211223151608074](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223151608074.png)

- •当分类回归树划分得太细时，会对噪声数据产生过拟合：
  - **预剪枝**：在每一次对结点进行划分之前，先采用验证集的数据来验证划分是否能提高结果的准确性。如果不能，就把结点标记为叶结点并退出进一步划分；如果可以就继续递归生成节点。
  - **后剪枝**：先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点。
  - 代价复杂性剪枝、最小误差剪枝、悲观误差剪枝……





# 文本读写技术：

- 使用python钟的pandas库来完成

- 读取txt文件的步骤：

  `fp = open('iris.txt','r')`

- 读取txt文件的说明：

  - <_io.TextIOWrapper name='iris.txt' mode='r' encoding='cp936'>表示txt文件已经成功打开。
  - open函数的第一个参数是需要打开文本的存储路径，第二个参数‘r’指open函数采用的模式为“读取模式”。

- 读取行：

  - 读取一行：`fp.readline()`
  - 读取所有行：`fp.readlines()`

![image-20211223152044506](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223152044506.png)

- 常用函数：
  - open(文本文件路径 , 读取模式（r , w , a , r+），其中r+是读写模式)
  - read()表示读取到文件尾，size表示读取大小
  - seek(0)表示跳到文件开始位置。
  - readline()逐行读取文本文件。
  - readlines()读取所有行到列表中，通过for循环可以读出数据。
  - close()关闭文件
- 完整代码：

```python
f = open("./image/abc.txt")
line = f.readline()
while line:
    print line
    line = f.readline()
f.close()
```

![image-20211223153707648](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223153707648.png)

![image-20211223153727168](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223153727168.png)

- 读取csv文件：

  - 将csv等表格型文件直接读取到一个Python的DataFrame对象里面。
  - 最常用的函数包括read_csv和read_table函数
  - pd = df.**read_csv**('iris.csv')，将iris.csv存储到df这个DataFrame里面。
  - pd = df.**read_table**('iris.csv'，',')，将iris.csv存储到df这个DataFrame里面。
  - 只想读取几行，而不是读取整个文件：`pd.read_table('iris.csv',nrows=5)`
  - 逐块读取文件：chunksize（行数） -> `chunck = pd.read_csv('iris.csv' , chunksize = 5)`
  - 迭代处理每一行，例如统计行数，for piece in chunk : total + 1

  ![image-20211223154306461](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223154306461.png)

- 写入文本文件：

  - 写入txt，就要先创建file对象，以'w'模式标记指定要写入的文件。

  ```python
  mydata = ['Date' , 'Time']
  myfile = open('testit.txt','w')
  for line in mydata:
      myfile.write(line + '\n')
  myfile.close()
  ```

  ```python
  for line in mydata:
      myfile.write(line + '\n')
  myfile.seek(0)
  myfile.read()
  # 显示  'Date\nTime\nDate\nTime\n'
  myfile.close()
  ```

  

- 数据库连接：

  - 引入数据库处理模块：

  `db = MySQLdb.connect("localhost","root","123456","myciti" )`

  - 注意：要在Python3中使用MySQLdb，在使用前添加命令：
    - import pymysql
    - pymysql.install_as_MySQLdb()
  - python3中使用mysql报错ModuleNotFoundError: No module named 'MySQLdb‘ 原因是：在python2.x中用mysqldb，但是在python3.x中已经不支持那个组件了。取而代之的是：import pymysql，解决方法：在项目文件夹下的_init_.py中导入pymysq包，import pymysql   pymysql.install_as_MySQLdb()

- 执行sql语句：

```python
import MySQLdb
db = MySQLdb.connect("localhost","root","123456","myciti" )
cursor = db.cursor()

sql="""insert into article values (0,"woainimahah","http://www.aa.com")"""
try:    
    cursor.execute(sql)    
    db.commit()
except:    
    db.rollback()
db.close
```

打印信息：

```python
import MySQLdb
db = MySQLdb.connect("localhost","root","123456","myciti" )
cursor = db.cursor()
cursor.execute("select * from article“)
               
datas = cursor.fetchall()
for data in datas:
	print data[1]
	print cursor.rowcount,"rows in tatal"
db.close
# Fetchall是取出数据库表中的所有行数据
# rowcount是读出数据库表中的行数
```

动态插入：

```python
import MySQLdb
title = "title"
url = "urlofwebpage "
db = MySQLdb.connect("localhost","root","123456","myciti" )
cursor = db.cursor()

sql = """insert into article values (0,"%s","%s","2012-9-8","wo","qq","skjfasklfj","2019","up")"""
try:    
    cursor.execute(sql%(title,url))
    db.commit()
except:    
    db.rollback()
db.close
```

update操作：

```python
import MySQLdb
title = "title"
id=11
db = MySQLdb.connect("localhost","root","123456","myciti" )

cursor = db.cursor()
sql = """update article set title = "%s" where id = "%d" """
try:    
    cursor.execute(sql%(title,id))    
    db.commit()
except:    
    db.rollback()
db.close
```



# 数据处理技术：

- 产生原因：存放在文件或者数据库中的原始数据并不总能满足数据分析应用的要求。通常，原始数据中存在不符合规范的数据格式，或者存在数据缺失的情况。在这些情况下，必须对原始数据进行包括加载、清理、转换和重塑等处理。

- 合并数据集：数据存储往往会按照物理含义，分别存储在不同的表钟，便于管理和操作。数据分析或者建模的时候，需要将不同的数据表进行关联和合并，找出不同数据项之间的内在关联。

- 索引上的合并：

  - df中，连接键有时会位于其索引中，需要传入left_index = True或right_index = True（或两个都传）以说明索引应该被用作连接键。
  - ![image-20211223191641829](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223191641829.png)
  - ![image-20211223191845552](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223191845552.png)
  - 默认的merge是交集部分，类似于mysql中的连接查询。但是也可以处理一下下：

  ![image-20211223192006954](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192006954.png)

  - Index为复合键：

  ![image-20211223192130995](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192130995.png)

  ![image-20211223192250568](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192250568.png)

  ![image-20211223192330996](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192330996.png)

  ![image-20211223192342709](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192342709.png)

  - 采用合并双方的索引来实现关联：

  ![image-20211223192455906](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192455906.png)

  ![image-20211223192503501](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192503501.png)

  ![image-20211223192526773](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192526773.png)

  - join函数的使用（还是上面的例子嗷！！！）：可以用于合并多个带有相同或者相似索引的DF对象，而不管是否有重叠的列。

  ![image-20211223192657299](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223192657299.png)

  - 由于一些历史原因（早期版本的pandas规定的），DataFrame的join函数默认是通过连接键上做左连接，对多个表进行关联的

  ![image-20211223193056456](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193056456.png)

- 轴向连接：

  - 另一种数据合并运算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy有一个用于合并原始NumPy数组的concatenation函数arr *=* np.arange(12).reshape((3, 4))

  ![image-20211223193209835](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193209835.png)

  - *np.concatenate**([**arr**,* *arr**], axis=1)*：

  ![image-20211223193224876](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193224876.png)

  - 当两个数据集的索引全部或部分重叠时，它们的数据组合问题就不能用简单的合并（merge）或连接（concatenation）运算来处理：

  ![image-20211223193350919](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193350919.png)

  ![image-20211223193400543](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193400543.png)

- 数据转换：

  - 过滤，清理以及其他转换工作。最常见的就是移除重复数据的工作。

  ![image-20211223193503544](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193503544.png)

  - duplicated方法返回一个布尔型Series，每行中的布尔值表示该行是否是重复的：

  ![image-20211223193548904](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223193548904.png)

  去除重复数据行：data.drop_duplicates()

  - 只希望根据某一列来过滤：`data.drop_duplicates(['k1'])`
  - duplicated和drop_duplicates还可以通过多列的联合取值来筛选数据，并且通过keep=‘last’保留重复数据中的最后一个。例子：`data.drop_duplicates(['k1', 'k2'], keep='last')`

- 数据替换方法：

  - 利用fillna方法填充缺失数据可以看做值替换的一种特殊情况。在通常的值替换时，往往采用replace方法，它提供了一种实现替换功能的简单、灵活的方式。

  ![image-20211223200320267](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200320267.png)

  ![image-20211223200334046](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200334046.png)

  ![image-20211223200352220](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200352220.png)

  ![image-20211223200409473](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200409473.png)

- 检测异常值：

  - 异常值（outlier）的过滤或变换运算在很大程度上其实就是数组运算。

  ![image-20211223200437119](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200437119.png)

  ![image-20211223200445365](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200445365.png)

  ![image-20211223200520924](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200520924.png)

  ![image-20211223200535729](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200535729.png)

- 排列和随机采样：

  - 利用numpy.random.permutation函数可以实现对Series或DataFrame的排列工作。通过需要排列的轴的长度调用permutation，可产生一个表示新顺序的整数数组：

  df *=* pd.DataFrame(np.arange(5 \* 4).reshape(5, 4))

  *sampler =* np.random.permutation(5)

  *Sampler* 显示 *array([1, 0, 2, 3, 4])*

  ![image-20211223200821119](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200821119.png)

  ![image-20211223200958852](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211223200958852.png)



# 数据分析技术：

- NumPy工具包：

  - NumPy的主要对象是**同种元素的多维数组**。在多维数组中，所有的元素都是一种类型的元素表格，且通过一个正整数下标进行索引。
  - ndarray对象中的属性有：
    - ndarray.ndim：表示数组轴的个数，被称为秩。
    - ndarray.shape：数组的维度，表示各个维度的大小。
    - ndarray.size：元素的总个数，各个维度元素个数的乘积。
    - ndarray.dtype：数组中的元素类型，可以来指定使用哪一种Python类型。
    - ndarray.itemsize：数组每个元素的字节大小，例如类型为float64的时候，itemsize为8
  - 例子：

  ```python
  >>> from numpy  import *
  >>> a = arange(15).reshape(3, 5)
  >>> a
  ```

  ![image-20211224095032710](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224095032710.png)

  `>>> a.shape   (3, 5)`，`>>> a.ndim   2`

  a.dtype.name -> 'int32'  ， a.itemsize -> 4 ，a.size -> 15

- 创建数组：

  - from numpy import *
  - a = array([2,3,4]) -> a.dtype = 'int32'
  - b = array([1.2, 3.5, 5.1]) -> b.dtype = 'float64'
  - c = array( [ [1,2], [3,4] ] , dtype=complex)
  - zeros((3,4)) -> 3行4列全是0
  - ones((2,3,4),dtype=int16) -> ![image-20211224095600671](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224095600671.png)
  - empty((2,3)) -> ![image-20211224095544847](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224095544847.png)
  - arange(10,30,5) -> *array([10, 15, 20, 25])*
  - arange(0,2,0.3) -> *array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])*
  - c = arange(24).reshape(2,3,4)

- 打印数组：

  - 特点：

  1. 从左到右打印最后的轴

  2. 从顶向下打印次后的轴

  3. 从顶向下打印剩下的轴，每个切片通过一个空行与下一个切片隔开

  - 一维数组以行的形式打印出来，二维数组以矩阵的形式打印出来，三维数组以矩阵列表的形式打印出来。

- 基本运算：

  - 数组按照元素进行算数运算的
  - 例子：

  *a = array( [20,30,40,50] )*

  *b =* *arange( 4 )* -> *array([0, 1, 2, 3])*

  

  c = a - b -> *array([20, 29, 38, 47])* *dtype**=**bool*

  b ** 2 -> *array([0, 1, 4, 9])*

  10 * sin(a) -> *array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854])*

  a < 35 -> *array([True, True, False, False],* *dtype=bool)*

  - NumPy乘法是按照元素进行计算的，矩阵乘法可以通过dot函数或者创建矩阵。
  - 例子：

  A = array([[1,1],[0,1]])

  B = array([[2,0],[3,4]])

  A * B -> *array([[2,0],[0,4]])*

  dot(A,B)(矩阵乘积) -> *array([[5, 4],* *[3, 4]])* 

  - 还有一些操作符，例如+=和*=，是用来更改现有的数组，而不是创建一个新的数组
  - 例子：

  *a = ones((2,3),* *dtype=int)*

  *b =* *random.random((2,3))*

  *a\*= 3* -> a = *array([[3, 3, 3],* *[3, 3, 3]])*

  *b += a* -> b = *array([[ 3.69092703, 3.8324276 , 3.0114541 ],[ 3.18679111, 3.3039349 , 3.37600289]])*

- upcast：

  - 当多种类型数组进行计算时，结果得到的数组通常采用更精确的值，这种行为叫做*upcast*（向上转型）

  - 例子：

    *a = ones(3,* *dtype=int32)*，*b =* *linspace(0,pi,3)*

    *c =* *a+b*

    *array([ 1., 2.57079633, 4.14159265])*

- 复制和视图：

  - 在处理数组时，需要将数据拷贝到新的数组中。通常来说，有三种处理情况。

  - 完全不拷贝：

    - *a =* *arange(12)*，*b = a*  ，*b.shape* *= 3,4*  -> *a.shape*

      -> *(3, 4)* 

  - 视图和浅复制：

    - 在这种情况中，不同的数组对象可以共同分享一组数据。视图方法可以构建一个新的数组对象，并指向同一组数据。

    - *c =* *a.view()* -> *c is a* -> False , *c.base* *is a*      *# c是数据**a**的一个视图* -> True

    - *c.shape* *= 2,6* -> *a.shape*  -> (3,4)（c虽然形状变了，但是用的还是a中的元素，c结构变了，a还没变嗷！）

    - *c[0,4] = 1234*   #c的数据会改变*a*，因为c实质上用的是a中的元素

      a = *array([[  0,  1,  2,  3],*

      ​    *[1234,  5,  6,  7],*

      ​    *[  8,  9,  10,  11]])*

  - 深复制：

    - 在深复制下，完全复制数组以及它的数据，创建一个新的数组，而不是分享共同的数据。
    - *d =* *a.copy()* 
    - *d is a* ， d.base is a -> False，d与a不共享任何数据



- Pandas工具包：

  - Pandas工具包的数据结构可以按轴自动地或显式地对齐数据。Pandas的这种特性可以防止许多由数据未对齐而导致的常见错误。
  - Pandas还可以集成其他功能，例如时间序列功能。这使得Pandas既能处理按照时间序列排列的数据，也能处理非时间序列排列的数据。
  - 具体使用：`from pandas import Series, DataFrame , import pandas as pd`

- Series：

  - 类似于一维数组，由一组数据以及对应的数据 **标签（索引）**组成，一组数据就可以产生最基本的Series
  - Series的字符串两部分组成，左边是索引，右边是值。没有创建数据索引，默认0~N-1。
  - 我们可以使用values和index这两个属性获取数组的值和索引对象：
    - *obj.values* -> *array([ 4, 7, -5, 3],* *dtype=int64)*
    - *obj.index* -> *Int64Index([0, 1, 2, 3],* *dtype='int64‘)*
  - 我们总是希望所有一个可以对各个数据点进行标记的索引:

  *obj2 =* *pd.Series([4, 7, -5, 3],* *index=['d', 'b', 'a', 'c'])*

  *index([u'd',* *u'b',* *u'a',* *u'c'],* *dtype='object')*

  *obj2['a']* -> *-5*

  *obj2['d'] = 6*

  *obj2[['c', 'a', 'd']]* -> ![image-20211224110021402](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224110021402.png)

- DataFrame：

  - DataFrame是一种表格类型的数据结构，它含有一组有序的列。每一列可以是不同类型的值（例如数值、字符串、布尔值等）。既可以按行索引，也可以按列索引，因而可以被视为由Series组成的字典。与其他数据结构相比，DataFrame中对行操作和对列操作基本上是平衡的。
  - 构建DataFrame的办法有很多种，其中最常用的办法就是直接传入一个字典：

  *data* *= {'state':['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year':[2000, 2001, 2002, 2001, 2002], 'pop':[1.5, 1.7, 3.6, 2.4, 2.9]}*

  *frame* *=* *pd.DataFrame**(data**)*

  DataFrame从而可以自动加上索引（跟Series一样），且全部的列都会进行有序地排列：

  ![image-20211224110207824](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224110207824.png)

  - 当我们指定了列序列以后，DataFrame的列就会根据特定的顺序进行排列：

  *pd.DataFrame**(data, columns=['year', 'state', 'pop'])*：

  ![image-20211224110252678](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224110252678.png)

  

- Scikit-Learn(SKLearn工具包)：

  - 基于Python的机器学习模块，实现了几乎所有常用的机器学习算法。

  ![image-20211224155430903](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224155430903.png)

  - 决策树：

    - `conda install pydotplus   conda install python-graphviz`
    - 鸢尾花数据集

    ![image-20211224155709313](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224155709313.png)

    - 代码实现：

    ```python
    from sklearn import tree
    from sklearn.datasets import load_iris
    from sklearn.metrics import accuracy_score
    from sklearn.model_selection import train_test_split
    import pydotplus
    
    iris=load_iris()
    # 特征
    iris_feature = iris.data
    # 分类标签
    iris_label = iris.target
    # 随机数据集划分，为了验证算法的正确性，需要将数据分成训练数据和测试数据
    X_train,X_test,Y_train,Y_test = train_test_split(iris_feature,iris_label,test_size=0.3,random_state=30)
    
    # 生成决策树
    clf=tree.DecisionTreeClassifier()
    # 训练
    clf=clf.fit(X_train,Y_train)
    # 预测
    predict=clf.predict(X_test)
    
    # 查看测试数据的预测值与真实值
    print(predict)
    print(Y_test)
    # 获得预测准确率，本例是96.67%
    print(accuracy_score(predict,Y_test))
    
    # 输出结果图
    dot_data = tree.export_graphviz(clf, out_file=None, 
                             feature_names=iris.feature_names,  
                             class_names=iris.target_names,  
                             filled=True, rounded=True,  
                             special_characters=True)
    graph = pydotplus.graph_from_dot_data(dot_data)
    graph.write_pdf("irisresult.pdf")
    ```

    决策树结果：

    ![image-20211224155847158](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224155847158.png)



# 数据可视化技术：

- Matplotlib绘图：

  - 最著名Python绘图库， 主要用于二维绘图。具有画图质量高、方便快捷的绘图模块等特点。

  - API入门：绘图API——pyplot模块，集成库——pylab模块（包含NumPy和pyplot中的常用函数）

  - 不同的图图们：

    - 折线图：

    ```python
    t = np.range(0.,4.,0.1)
    plt.plot(t,t,t,t+2,t,t**2)
    plt.show()
    ```

    - 散点图：`plt.plot(listKOIndex,listKO,'O')`
    - 柱状图：`plt.bar(listKOIndex,listKO)`

  - Pylab绘图：

    - 例子：

    ```python
    import pylab as pl
    t = np.arange(0.,4.,0.1)
    pl.plot(t,t,t,t+2,t,t**2)
    ```

    - 默认可以控制的属性：

    ![image-20211224161350704](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161350704.png)

    - 色彩和样式：`plt.plot(x,y,'g--') / plt.plot(x,y,'rD')`

    ![image-20211224161447886](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161447886.png)

    - 文字：xlabel , ylabel , title , 每一个plot后面都有一个label属性 , legend里面可以标注位置嗷！！！

    ![image-20211224161625640](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161625640.png)

    - 子图属性：

      - subplot：

      ![image-20211224161712474](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161712474.png)

      - axes：

      ![image-20211224161723391](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161723391.png)

  - Pandas绘图：

    - ![image-20211224161846042](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161846042.png)

    ![image-20211224161915365](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161915365.png)

    - ![image-20211224161926448](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161926448.png)
    - Pandas控制图像样式：

    ![image-20211224161941523](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224161941523.png)

    ![image-20211224162006281](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162006281.png)

    ![image-20211224162012390](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162012390.png)

    ![image-20211224162017700](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162017700.png)

    ![image-20211224162023408](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162023408.png)

- Biopython：

  - ![image-20211224162046821](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162046821.png)
  - ![image-20211224162101859](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162101859.png)

- 实例：

  - 语料库（NTLK）：

  ![image-20211224162131923](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162131923.png)

  ![image-20211224162141807](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162141807.png)

- 实例2：

  - 大屏数据可视化

  ![image-20211224162201960](%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.assets/image-20211224162201960.png)

  - 数据可视化，是关于数据视觉表现形式的科学技术研究。其中，这种数据的视觉表现形式被定义为，一种以某种概要形式抽提出来的信息，包括相应信息单位的各种属性和变量。

  - 大屏可分为信息展示、数据分析、监控预警三大类。利用屏幕大可展示信息多的特点，将复杂、抽象的内容通过可视化更加直观的方式，以易于理解的形式帮助人们更好决策。

  - 简单的说，大屏就是就是一个巨大化的Dashboard（仪表盘）

  - 注意事项：

    - 条件允许的情况下，设计前先用的不同风格设计在屏幕上投放，了解颜色差距，对比色临近色、渐变色等在大屏上是否存在色差

    - 等比例放大投射会发虚问题：

      （1）大屏逻辑分辨率（设计分辨率）

      （2）显卡输出分辨率

      （3）视频矩阵切换器（DVI）支持分辨率

      （4）大屏实际物理分辨率 。

    - 大屏显示被拉伸或压缩，可能由于视频扩展器显示不正确导致压缩或拉伸，那么需要了解被压缩的比例，并对其进行校正。

- 可视化参考样式：

  - 图表工具：Apache ECharts、Highcharts。
  - 第三方开发工具：DataV数据可视化、腾讯云图、百度智能云。原生开发：HTML5、JS、CSS、WebGL、unity。



